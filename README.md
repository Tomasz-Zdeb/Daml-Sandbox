# Daml Sandbox

An overview guide on [Daml](https://www.digitalasset.com/developers) language.

## Getting started

[Daml docs](https://docs.daml.com/getting-started/installation.html#) provide a great **Getting Started** guide. This project will be based on **Daml Open Source**.

> Please take into account that projects generated by **Daml** toolkit may be provided under different licensing terms than this guide.

```powershell
daml version
```

Displays versions of installed SKDs.

```powershell
daml new <project_name>
```

Creates new project with a specified name and default template. To specify the template use:

```powershell
daml new <project_name> --template <template_name>
```

```powershell
daml new --list
```

Lists all the available project templates

## Templates

They are the most important component of **Daml** ecosystem. They define **data** and **behavior** of **Contracts** on **Daml Ledger**. Which means they provide logic that answers these questions:

* Who can see what?
* Who can alter the ledger?
* How can they alter the ledger?
* Under what conditions?

### `With` section

**Template** declaration must start with: `with` section. Data fields are defined in the `with` section.

> The requirement the `with` section is to contain at least one `Party`.  

```haskell
template MyOffer
  with
    issuer: Party
    owner: Party
    price: Decimal
    royaltyRate: Deciaml
    (...)
```

> In general `with` section a mix of **Parties** included in the contract as well as the contract's **payload**.

### `where` section

The `where` section contains:

* `signatory` - list of **Parties** that are being stated as **signatories** of the **contract**. A **signatory** is a participant in a contract which consented to the creation of that template.

  >The requirement is to have at least one **Party** stated as the signatory

* `observer` (optional) - including **Parties** as **observers** allows to make these **Parties** aware of the contract. Whereas if some **Party** is specified in the `controller` block, the **Party** will be aware of the contract anyway, so the `observer` block should be used for granting the right to see the contract to additional **Parties**.

* `ensure` (optional) - boolean expression, that has to be `true` for the contract creation. E.g.  

  ```haskell
  ensure royaltyRate >= 0.0 && lastPrice >= 0.0
  ```

* `key` - a uniqe identifier of a token E.g.

  ```haskell
  key (issuer, owner, description): (Party, Party, Text)
  ```

  means that combination of these three data items must be unique. All data types can be used for `key` construction.

* `maintainer` - a **Party** responsible for `key` uniqueness (although `key` uniqueness if provided by the ledger itself)

* other blocks that create so called **choices**

### Choices

> A template can include **zero or more** **choices**. **Choices** are very important, because they define the rules on how the ledger can be changed, like: **who can change** the ledger? under **what conditions** and **what do** these changes actually **mean**?

The most of **daml** action will be taking place inside the **choice's** body. Despite choices there is only one other way to mutate the ledger - create contract from scratch. But only contract with single signatory can be created from scratch, so once again - most of the ledger updated will take place as the result of **choice** execution.

* `controller` is an obligatory part of every **choice** that indicate what **Parties** can exercise the **choice**. All of the specified `controller` **Parties** have to sign off to perform the **choice** execution.

  ```haskell
  controller newOwner, userAdmin can 
  ```

* **Name** of the **choice** followed by **return type** is the next element of choice structure E.g.

  ```haskell
  controller newOwner, userAdmin can 
    AcceptToken: ContractId Token
  ```

  **choice's** **return type** provides convenience, to other **choice** that might be calling this one, so the other **choice** can get a handle on the result of executing that **choice**.

  There is no necesisty to include all the results of a **choice** in the **return type**, but it is convenient to do so.

  If the **return type** is specified, the last line of the **choice** with the **return** statement and returned object, must match the type with the **return type**.

* **Parameters** (optionally) can be specified as a next part, using `with` keyword.

* **Body** of the choice, starting with `do` keyword.

  All the actions one would like to perform are being defined there. E.g.
  * asserting any features of parameters that have been passed in
  * archiving actions
  * creating actions
  * any other ledger updates

Example **choice** could look something like this:

 ```haskell
do
  newToken <- create Token
    with
      owner = newOwner
      lastPrice = price
      (...)
  return newToken
 ```

In above example new **Token** is being created, it's properties are being initialazed with values: **newOwner** and **price**, which are data fields of the template. The **token** is assigned to the variable **newToken**.

> despite creating the Token it is also being **archived**, but this does not need to be specified, since it's the default behaviour - always the contract from from which choice is called is being removed from the active state of the ledger. This behaviour can be overriden by `non consuming` keyword.

---

## References

* [Daml Docs](https://docs.daml.com/)

* [Daml Developer forum](https://discuss.daml.com/)

* [Daml Cheat Sheet](https://docs.daml.com/cheat-sheet)

* [Daml Talent Lms (requires account)](https://daml.talentlms.com/dashboard/index)
